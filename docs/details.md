# Принцип работы

goofy это конструктор с набором функций на JavaScript. С их помощью составляется алгоритм, который автоматизирует различные задачи. К примеру, найти любимые треки, которые давно не прослушивались.

Выполнение алгоритма происходит на стороне платформы Google Apps Script. То есть задачи выполняются по расписанию без вашего участия.

?> При установке или изменении версии, отправляется единичный запрос в Google Формы. Чтобы иметь представление сколько пользователей активно используют goofy.

## Отличия от Smarter Playlists

Главное отличие заключается в способе составления алгоритма. В Smarter Playlists визуальный язык, диаграмма. В случае goofy используется язык программирования.

Пример следующего алгоритма в Smarter Playlists: взять треки из двух плейлистов, выполнить случайную сортировку, сохранить первые 50 треков в новый плейлист.

![Пример создания плейлиста в Smarter Playlists](/img/SmarterPlaylistsExample1.png)

Теперь тоже самое с помощью goofy
```js
let tracks = Source.getTracks([
  { name: 'Микс дня 1', id: '123' },
  { name: 'Микс дня 2', id: '456' },
]);

Order.shuffle(tracks);

Playlist.saveAsNew({
  name: 'Личный микс дня',
  tracks: Selector.sliceFirst(tracks, 50),
});
```

## История прослушиваний

goofy автоматически отслеживает историю прослушиваний. При достижении предела (60 тысяч), новые прослушивая по-прежнему сохраняются за счет удаления самых старых. Процесс отслеживания начинается сразу после завершения настройки. Прослушивания, произошедшие до настройки не попадут в список. Однако есть способ добавить их вручную, при наличии last.fm.

?> В новый аккаунт last.fm можно [добавить](https://support.last.fm/t/how-to-add-scrobbles-history-from-spotify-to-last-fm/40038) историю прослушиваний, которая была до создания аккаунта.

У Spotify API есть функция для получения истории прослушиваний. Но *максимум* 50 последних треков, которые прослушаны более чем 30 секунд. В историю не попадают подкасты и треки, прослушанные в приватном режиме.

Возможность goofy отслеживать историю появляется за счет платформы Apps Script и её доступа к Google Drive. Каждые 15 минут goofy обращается к Spotify и обновляет содержимое файла на диске новыми данными.

Теоретически, лимит истории можно увеличить до 100 тысяч. Но возникает вопрос производительности в рамках лимитов платформы Apps Script, доступности дискового пространства и в целом целесообразности такого массива. Поскольку в большинстве случаев такая история нужна для удаления треков из вновь создаваемых плейлистов. Задачи по составлению топа легко решаются другими средствами при наличии Last.fm.

Last.fm способен сам отслеживать прослушивания Spotify (подключение в [профиле](https://www.last.fm/settings/applications)). Но все перечисленное не позволяет перехватить быстрые пропуски треков. Для этого есть два решения: 

- Первое подробно [описано на форуме](https://github.com/Chimildic/goofy/discussions/53).
- Второе заключается в том, чтобы отключить отслеживание Last.fm и использовать сторонние программы для ПК и смартфона, которые позволяют задать промежуток в несколько секунд, после которых трек сохраняется в историю. Например, [Pano Scrobbler](https://4pda.to/forum/index.php?showtopic=887068). 

На практике Spotify API работает нестабильно. Трек после 30 секунд может вернуться с задержкой или совсем потеряться. Проблема со стороны Spotify, которая никак не решается. Однако вместе с Last.fm это становится совсем незначительным. 

Если вы часто слушаете скачанные треки без подключения к интернету, используйте сторонние скробблеры, как в примере выше. Они позволяют сохранять прослушивания локально и убрать зависимость от офлайна и сбоев Spotify. Если офлайн прослушивания это редкий сценарий, достаточно подключения через профиль.

## Ограничения

?> При первом знакомстве некоторые детали могут быть непонятны

Библиотека подчиняется ограничениям со стороны платформ. Ниже описание конкретных показателей и на что они влияют на основе справочной информации, предлагаемой платформами.

### Apps Script {docsify-ignore}
- Выполнение скрипта (6 минут / одно выполнение)

  - Общая максимальная продолжительность *одного* запуска скрипта. Как правило, легкие шаблоны завершаются за считанные секунды. Приблизиться к минуте или нескольким можно в случае большого объема входных и/или выходных данных.
  - Например, функция [getFollowedTracks](/reference/source?id=getfollowedtracks) для пользователя [spotify](https://open.spotify.com/user/spotify) и аргументу `owned` в среднем отрабатывает за 4 минуты. При этом получая 1.4 тысячи плейлистов и 102 тысяч треков. После удаления дубликатов остается 78 тысяч. 
  - Если для 78 тысяч вызвать [rangeTracks](/reference/filter?id=rangetracks) лимит 6 минут будет превышен. Но предварительно отбросив заранее неподходящие треки, например, с помощью [rangeDateRel](/reference/filter?id=rangedaterel), [match](/reference/filter?id=match) и прочего, можно существенно и быстро снизить количество треков.

- Количество запросов (20 тысяч / день)

  - Как правило, 1 запрос к Spotify это получение 50 плейлистов или 50 треков. В некоторых случаях 100.
  - Пример выше получил 1.4 тысяч плейлистов и 102 тысячи треков за 1 735 запросов.
  - На получение 11 тысяч треков плейлиста 110 запросов и 25 секунд. Примерно столько же на создание плейлиста с таким количеством треков.
  - На получение 10 тысяч любимых треков уйдет 200 запросов.
  - В целом, сложно представить функцию на 20 тысяч запросов из-за ограничения 6 минут на выполнение. По этой причине можно сказать, что нельзя обойти все плейлисты роботов-пользователей с тысячами плейлистов. Но личный профиль или средних авторов можно.

- Выполнение триггеров (90 минут / день)

   - Общая максимальная продолжительность выполнения триггеров. Единственный способ достичь предела это вызвать 15 раз функцию на 6 минут за один день. Сложно представить задачу, которая потребует этого и оправдает себя. 

- Количество триггеров (20 / пользователь / скрипт)
  
   - При грубом описании это 20 плейлистов, которые создаются по совершенно *разному* расписанию. 
   - На практике, несколько функций можно вызывать из одной другой функции, что позволяет создать N плейлистов за один триггер. Подробнее [здесь](/best-practices?id=Экономика-триггеровв).
   - Кроме того, можно создать еще одну копию библиотеки и также получить квоту на 20 триггеров.
  
     > Если вам потребовалось создать еще одну копию, можете повторно использовать значения CLIENT_ID и CLIENT_SECRET и не создавать новое приложение на стороне Spotify.

Остальные ограничения Apps Script не относятся к библиотеке. Они связаны с почтой, таблицами и прочими сервисами. Или недостижимы из-за ограничений Web API Spotify. Подробнее [здесь](https://developers.google.com/apps-script/guides/services/quotas).

### Web API Spotify {docsify-ignore}
- Локальные файлы игнорируются. [API не позволяет](https://developer.spotify.com/documentation/general/guides/local-files-spotify-playlists/) добавлять такие треки в новые плейлисты и практически не несут в себе данных для фильтрации, сортировки.
  
  > It is not currently possible to add local files to playlists using the Web API, but they can be reordered or removed.

- Количество треков 
  - При добавлении в плейлист до 11 тысяч треков.
  - При получении с одного плейлиста также 11 тысяч.
  - Любимые треки до 20 тысяч.
  - При фильтрации, сортировке, выборе количество неограниченно. Но в пределах квоты Apps Script.
- Количество плейлистов
  - Теоретически до 11 тысяч, но не хватит квоты Apps Script на получение треков с них. Реальное значение в пределах 2 тысяч. Зависит от общего количества треков.
- Количество запросов
  - Точного числа нет. При слишком большом объеме запросов за короткий промежуток времени могут появиться ошибки 500, 503 и подобное. Проходят после паузы. 
  
### Google Диск {docsify-ignore}
- Размер одного текстового файла ограничен - 50 мб. Для сокращения объема можно использовать функцию [Cache.compressTracks](/reference/cache?id=compresstracks). Экспериментально удалось создать файл со 100 тысячами **сжатых** треков и уложиться в 50 мб.


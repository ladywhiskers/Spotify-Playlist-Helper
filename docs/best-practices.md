# Полезный опыт

Советы по работе с goofy и Apps Script

## Ветвление алгоритма

Алгоритм не обязан быть линейным. Если по какой-то причине не нужно обновлять плейлист, функцию можно прервать.

Предположим, есть ежедневный плейлист, который не нужно обновлять в среду. Чтобы это реализовать, напишем условие проверки. Тем самым создав ветвление кода. 

?> О работе условия `if` почитайте отдельно [здесь](https://itchief.ru/javascript/сonditional-and-logical-operators)

Ключевое слово `return` используется для возврата значения из функции. Код после этой команды никогда не выполняется. Использование `return` без возвращаемого значения - частный случай, принимающая сторона получит значение `неопределенно`. В случае запуска с триггера, это просто эквивалент того, что функция завершилась.

Пример демонстрирует, что если сегодня среда - завершаем функцию. Код после `return` не выполниться. Но если сегодня другой день недели, исполнение не попадет в ветку `if`, то есть не выполнит команду `return`, и пойдет дальше - к логике обновления плейлиста.
```js
if (Selector.isDayOfWeekRu('среда')){
    console.log('Сегодня среда. Плейлист не будет обновлен.');
    return;
}

// Логика обновления плейлиста
let tracks = Source.getPlaylistTracks('', 'id');
// ...
```

Другая ситуация. Имеем плейлист с 40 треками. Переодически слушаем его. Добавим несколько ветвлений в зависимости от количества прослушанных треков. К примеру, если не прослушано менее 10 включительно, обновим все треки. От 10 до 40 не включительно, удалим прослушанные из плейлиста. При 40 не трогаем плейлист.

```js
const ID_TARGET = 'id результата';

let tracks = Source.getPlaylistTracks('', ID_TARGET);
Filter.removeTracks(tracks, RecentTracks.get());

if (tracks.length == 40) {
    return;
} else if (tracks.length > 10 && tracks.length < 40) {
    Playlist.saveWitUpdate({
        id: ID_TARGET,
        tracks: tracks,
    });
} else {
    Playlist.saveWithReplace({
        id: ID_TARGET,
        tracks: Source.getPlaylistTracks('', 'id источника'),
    });
}
```

!> Внимательно следите за словом `length`. В нем очень просто допустить опечатку.

## Выполнение отладки

Отладка позволяет остановить выполнение кода в любом месте и проанализировать значения к этому моменту.

К примеру, нужно получить все названия треков. Но какой ключ у этого поля: `title`, `name`, `label`, `trackname`? Перебирать долго и неудобно. Выполнив отладку, увидите все доступные ключи у трека и других элементов.

?> Документация от Spotify находится [здесь](https://developer.spotify.com/documentation/web-api/reference/)

Установите точку остановки нажав рядом с номером строки, выберите функцию и нажмите `отладка`.

![Отладка](/img/fp-debug.gif)

В результате, справа откроется отладчик, где можно посмотреть промежуточные значения переменных, а также продолжить выполнение по шагам. Сверху 4 кнопки: запуск (до следующей точки или до конца), шаг с обходом, шаг с заходом внутрь и шаг с выходом изнутри. Попробуйте самостоятельно, чтобы понять на практике.

![Отладчик](/img/debuger.png)

Запуская функцию через триггер может понадобится различная информация. К примеру, какое количество треков было до и после фильтров. Для вывода подобных сообщений используйте функцию `console.log`.
```js
let tracks = Source.getSavedTracks();
console.log('Количество любимых треков', tracks.length);
```

![Пример логов](/img/example-log.png)

Решая задачу получения названия треков, выведем их следующим образом
```js
let tracks = Source.getSavedTracks();
tracks.forEach(track => console.log(track.name));
```

Кроме того, полезным будут [горячие клавиши](https://github.com/Chimildic/goofy/discussions/112) для быстрого перехода к описанию функции прямо из редактора кода.

## Несколько аккаунтов

Один Google аккаунт (Apps Script) может управлять несколькими аккаунтами Spotify (начиная с версии goofy 1.6.1).

Чтобы настроить goofy для дополнительного аккаунта Spotify, повторите шаги [установки](https://chimildic.github.io/goofy/#/install), но при этом:

1. Скопируйте goofy проект, как вы это делали на [шаге 4 при установке](https://chimildic.github.io/goofy/#/install).
2. Используйте те же значения `CLIENT_ID`, `CLIENT_SECRET`, `PRIVATE_CLIENT_ID`, `PRIVATE_CLIENT_SECRET` в _config_ файле (т.е. пропустите шаги 1-2).
3. При выдачи прав доступа на шаге 10 входите через новый аккаунт Spotify.

Теперь у вас два проекта с goofy: основной и копия. Каждая авторизована под разные Spotify аккаунты. Проекты могут взаимодействовать друг с другом:

- Общий диск. Используя [путь до файла](/best-practices?id=Путь-до-файла) функции [Cache](/reference/cache) умеют работать с файлами из других папок. По умолчанию каждый проект пишет файлы в папку с id аккаунта. То есть вы можете обновлять файлы в одном проекте и читать их в другом. 
- Выполнив дополнительные шаги, вы сможете вызывать функции в проекте-копии находясь в проекте-основе. Функция запущенная таким образом будет использовать токен того аккаунта, в проекте которого находится.

### Управление копией

1. Зайдите в настройки проекта-копии и скопируйте его идентификатор.

![Идентификатор проекта](/img/cross-project-id.png)

2. Теперь зайдите в основной проект. Напротив слова `библиотеки` нажмите кнопку плюса. Скопируйте идентификатор проекта из первого шага и укажите читаемое имя в поле идентификатор библиотеки. Например, никнейм второго Spotify аккаунта.

![Добавление библиотеки](/img/cross-add-library.png)

3. Чтобы проект-основа мог использовать функции проекта-копии необходимо создать публичные функции в копии. Обычно это просто обертка над функцией goofy. При этом важно указать возврат результата `return` и повторить входные аргументы (иногда их больше одного, сверяйтесь с документацией). 

```js
// проект-копия
function saveWithReplace(data) {
  return Playlist.saveWithReplace(data)
}

function getFollowedTracks(params) {
  return Source.getFollowedTracks(params)
}

function getSavedTracks(limit) {
  return Source.getSavedTracks(limit)
}

function getUserId() {
  return User.id
}
```

Теперь остается обращаться к `CopyGoofy` для вызова функций.

```js
// проект-основа
function example() {
  // Треки от основы
  let followedTracksFirstAccount = Source.getFollowedTracks({ type: 'followed' })
  // Треки от копии
  let followedTracksSecondAccount = CopyGoofy.getFollowedTracks({ type: 'followed' })

  // Создать плейлист под основой
  Playlist.saveWithReplace({
    // ...
  })

  // Создать плейлист под копией
  CopyGoofy.saveWithReplace({
    // ...    
  })

  // Из-за особенностей Apps Script следующий синтаксис невозможен. Именно поэтому создаются функции-обертки.
  // Ошибка: CopyGoofy.Playlist.saveWithReplace()
}
```

Также основа может читать файлы напрямую из папки копии
```js
// проект-основа
Cache.read(`root/${CopyGoofy.getUserId()}/filename.json`)
```

## Палитра команд

Палитра команд - это список действий, доступных редактору кода. Приведем некоторые полезные из них.

Установите курсор на любой строке кода и нажмите кнопку <kbd>F1</kbd> или вызовите контекстное меню правой кнопкой мыши и выберите палитру. В верхней части находится поле ввода для быстрого поиска команд. Справа от названия указываются горячие клавиши, если они доступны. Например, введите слово `шрифт`.

![Палитра команд - Шрифт](/img/cmdp-font.gif)

- Быстрое копирование. Установите курсор в любом месте строки. Зажмите клавиши <kbd>Shift</kbd><kbd>Alt</kbd> и нажимайте <kbd>↓</kbd>. Тот же эффект произойдет с выделенным фрагментом кода.
  
  ![Быстрое копирование](/img/cmdp-fast-copy.gif)

- Вертикальное выделение. Установите курсор в требуемое место. Зажмите клавиши <kbd>Shift</kbd><kbd>Alt</kbd> и проведите мышкой в противоположный угол.
  
  ![Вертикальное выделение](/img/cmdp-vertical-select.gif)

- Вертикальное выделение без мыши. Доберитесь стрелками до нужного положения. Зажмите <kbd>Ctrl</kbd><kbd>Alt</kbd> и нажимайте стрелку вверх или вниз. Теперь зажмите <kbd>Ctrl</kbd><kbd>Shift</kbd> и нажимайте стрелку вправо или влево.
  
  ![Вертикальное выделение без мыши](/img/cmdp-vertical-select-no-mouse.gif)

- Переименование. Выделите слово, например переменную, и нажмите <kbd>F2</kbd>. Все упоминания сменятся на новое имя.
  
  ![Переименование переменной](/img/cmdp-rename-f2.gif)

- Перемещение строки. Установите курсор в любое место строки. Зажмите <kbd>Alt</kbd> и нажимайте стрелку вверх или вниз. Аналогично для выделения.
  
  ![Перемещение строки](/img/cmdp-move-code.gif)

- Действие с комментарием. Установите курсор в любом месте строки, нажмите <kbd>Ctrl</kbd><kbd>/</kbd>, строка будет закомментирована. Повторное нажатие уберет комментарий. Аналогично для выделенного фрагмента.
  
  Для многострочного комментария используется комбинация <kbd>Shift</kbd><kbd>Alt</kbd><kbd>A</kbd>
  
  ![Многострочный комментарий](img/cmdp-fast-comment.gif)

- Комбинация для быстрого форматирования <kbd>Shift</kbd><kbd>Alt</kbd><kbd>F</kbd>
- Также может стать полезным сворачивание и разворачивание всего кода. Комбинации нет, ищите в палитре.

## Поиск значения

Существует несколько способов найти значение элемента. Например, жанры исполнителя или минимальную границу энергичности трека.

### Консоль Spotify

Наиболее простой способ это консоль Spotify. Надстройка, которая вызывает методы API с заданными параметрами. 

1. Зайдите в [консоль](https://developer.spotify.com/console/) и найдите необходимый метод API. Например, [исполнитель по _id_](https://developer.spotify.com/console/get-artist/).
2. Нужен токен для совершения запроса. Нажмите кнопку `get token`. В открывшемся списке, обратите внимание на примечание `not require a specific scope`. Если оно есть, просто нажмите кнопку `request token`. В противном случае, ниже примечания будет перечень чекбоксов, которые нужно прокликать. Нижний большой список не трогайте.
3. Добавьте _id_ исполнителя в поле и нажмите кнопку `try it`.

В правой части появится ответ, который дает все доступные атрибуты исполнителя. К примеру, жанры. Именно их следует использовать в [rangeTracks](/reference/filter?id=rangetracks) для `genres` или `ban_genres`
```js
"genres": [
    "candy pop",
    "emo",
    "pixie",
    "pop emo",
    "pop punk"
]
```

### Пошаговая отладка

Менее удобный способ. Во многом зависит от того, какие данные необходимо найти. 

[Выполняя отладку](/best-practices?id=Выполнение-отладки), установите точку остановки после интересуемой строки. Например, после получения списка исполнителей. Отладчик покажет массив элементов. В нем неудобно искать значение конкретного исполнителя.

![Найти жанры исполнителя](/img/find-genres.png)

### Вывод в лог

Элементы перебираются в цикле, нужная информация выводится в лог. Не подойдет для поиска данных, скрытых внутри библиотеки. Например, [особенности трека](/reference/desc?id=Особенности-трека-features) напрямую не отдаются и функции для их получения недокументированны. Естественно допускается модификация кода библиотеки, но данный способ здесь не отражен.

```js
// Исполнитель и его жанры
artists.forEach(a => console.log(a.name, a.genres));

// Список вида: исполнитель - трек
console.log(tracks.map(t => `${t.artists[0].name} - ${t.name}`).join('\n'));
```

## Продвинутый триггер

В пункте [экономика триггеров](/best-practices?id=Экономика-триггеров) описан способ сокращения триггеров за счет объединения функций со **схожим расписанием**. Например, обновление ежедневных плейлистов. То есть вместо схемы "1 триггер = 1 функция" перейти к "1 триггер = 2+ функции". В этом пункте описывается способ "1 триггер = все функции", не зависимо от схожести расписания.

В качестве иллюстрации, функция `runTasks_`. Она активируется одним триггером каждые 15 минут, но выполняет три функции (задачи) в разное время благодаря Клерку: обновление истории прослушиваний каждые 15 минут, добавление новых лайков в кэш каждый день и перезапись кэша лайков, на случай удаления треков, каждую неделю.

Клерк это программный модуль `Clerk` с двумя функциями:
- `runOnceAfter` - выполнять задачу каждый день один раз после заданного времени суток.
- `runOnceAWeek` - выполнять задачу в определенный день недели после заданного времени суток.

Описание функций в [документации](/reference/clerk)

### Разбор примера {docsify-ignore}

Согласно пометкам в комментариях

1. Установлен триггер каждые 15 минут на функцию `runTasks_`.
2. Функция `RecentTracks.update()` запускается каждые 15 минут без дополнительных условий и проверок.
3. Проверка временного условия. Если функция `updateSavedTracks` запускалась, то `isUpdatedSavedTracks` содеражит `true`, иначе не запускалась и `false`.
4. Если функция `updateSavedTracks` не запускалась - запустить `appendSavedTracks` при условии заданного времени. Иначе не запускать.

```js
// Триггер: каждые 15 минут (1)
function runTasks_() {
    RecentTracks.update() // запускается каждые 15 минут (2)
    let isUpdatedSavedTracks = Clerk.runOnceAWeek('monday', '01:00', updateSavedTracks) // (3)
    !isUpdatedSavedTracks && Clerk.runOnceAfter('01:00', appendSavedTracks) // (4)

    function updateSavedTracks(tracks) {
      // запускается каждый понедельник после часа ночи
    }

    function appendSavedTracks() {
      // запускается каждый день после часа ночи
    }
}
```

## Скрытие функции

Существует два способа для скрытия функций. Такую функцию нельзя запустить напрямую в редакторе кода и она не доступна для триггера.

Первый способ. Полезно для сокращения списка выбираемых функций при создании триггера. Кроме того, пример использования в [экономике триггера](/best-practices?id=Экономика-триггеров).

Добавить в конец имени нижнее подчеркивание. В примере, функция `create` доступна к запуску, а `update_` нет. 

```js
function create(){}

function update_(){}
```

- Таким способом сокрыта функция `runTasks_` (триггер для нее создан программно). 
- Функцию `doGet` скрывать не рекомендуется. Она нужна для авторизации и [управления с телефона](/addon?id=Управление-с-телефона).
- Функцию `setProperties` можно скрыть таким образом. Но при необходимости обновления параметров нужно вернуть обычное имя, чтобы получить возможность запуска в редакторе.

Второй способ. Полезно для выделения повторяющихся блоков. Например, когда разные источники требуют одинаковый набор фильтров.  

JavaScript позволяет определять функцию внутри другой. Тем самым сокращая область видимости. В примере, функция `get` доступна для вызова внутри `append`, но не видна внутри `update`. 

```js
function update(){}

function append(){

    function get(){}
}
```

## Экономика запросов

Apps Script ежедневно выдает квоту на отправку запросов - 20 тысяч. При достижении предела, невозможно получать треки, изменять плейлисты. Точное время обновления квоты неизвестно.

У функций, совершающих много запросов за один вызов, есть соответствующее примечание в [их описании](/reference/index). Более простые функции тоже могут забрать лишнего. Основная причина в количестве треков. Например, для 1 тысячи любимых треков понадобится 10 запросов. Для 10 тысяч уже 100 запросов. Проецируя на квоту, это незначительное количество для одного дня. Поэтому бессмысленно реализовывать механизм накопления через `Cache`. Но легко совершить логические ошибки.

?> Сокращение количества запросов экономит квоту и время исполнения.

Допустим, нужно удалить любимые треки из источника и случайно отобрать десяток любимых треков для плейлиста.
```js
// Правильный вариант
let topTracks = Source.getTopTracks('long');
let savedTracks = Source.getSavedTracks();

Filter.removeTracks(topTracks, savedTracks);
Selector.keepRandom(savedTracks, 10);
```

Возможно совершить несколько ошибок. Примеры не выдуманы, они встречались в алгоритмах от пользователей goofy.
```js
// Не создавать переменную для savedTracks
// Ошибка: дважды запрос одних и тех же треков
Filter.removeTracks(topTracks, Source.getSavedTracks());
let tracks = Selector.sliceRandom(Source.getSavedTracks(), 10);

// Вызвать Selector раньше Filter
// Ошибка: из topTracks удалится не все (если конечно это не нужно специально)
Selector.keepRandom(savedTracks, 10);
Filter.removeTracks(topTracks, savedTracks);

// Пытаться исправить предыдущую ошибку
// Ошибка: снова лишние запросы
Selector.keepRandom(savedTracks, 10);
Filter.removeTracks(topTracks, Source.getSavedTracks());
```

1. Когда алгоритм требует участия одного и того же набора элементов, попробуйте изменить порядок. Как это сделано в _правильном варианте_ выше. То есть использовать полный набор везде где нужно и только потом его модифицировать.
2. Если так поступить нельзя, создайте копию вместо новых запросов. 
```js
let savedTracks = Source.getSavedTracks();
let copySavedTracks = Selector.sliceCopy(savedTracks);
```

Функция `getCountRequest` вернет значение, соответствующее тому числу запросов, которые были совершены от начала запуска до вызова функции. Значение не кэшируется. При каждом запуске отсчет начинается с нуля. Добавьте следующую строку кода в конец своей функции. Так вы сможете сравнить качество проведенной оптимизации. 
```js
console.log('Число запросов', CustomUrlFetchApp.getCountRequest());
```

При этом учитывайте влияние функций, которые способны отбирать _случайное_ количество элементов. Например, у каждого исполнителя свое количество альбомов. Поэтому в дальнейшем это повлияет на число совершенных запросов при каждом новом запуске.

## Экономика триггеров

Согласно [ограничением](/details?id=Ограничения), на один проект (копию библиотеки) приходится 20 триггеров. При этом один всегда занят обновлением истории прослушиваний.

Предположим, что есть 3 ежедневных плейлиста. Каждая функция вызывается отдельным триггером. 

```js
function createSavedAndForgot(){}

function createDailyMix(){}

function createRecom(){}
```

Если время запуска не имеет особого значения, объединим функции. Тем самым экономя 2 триггера.
- [скроем функции](/best-practices?id=Скрытие-функции)
- удалим предыдущие триггеры
- создадим новый триггер для объединяющей функции `createEveryDayPlaylists`

```js
function createEveryDayPlaylists(){
    createSavedAndForgot_();
    createDailyMix_();
    createRecom_();
}

function createSavedAndForgot_(){}
function createDailyMix_(){}
function createRecom_(){}
```

?> При этом важно проследить за другим ограничением - временем выполнения (6 минут). Для корректной работы, время выполнения совокупности объединенных функций не должно превысить этот предел.

## Google Drive

### Путь до файла

С версии 1.6.1 поддерживается создание файлов в папках. Все данные по-прежнему размещаются в корневой папке `Goofy Data`. Скрипты предыдущих версий не требуют изменений.

Создаваемые папки делятся на два вида:
- _Папки аккаунта_. Создаются автоматически в корне с именем _id_ аккаунта Spotify.
- _Пользовательские_. Создаются вами при использовании модуля [Cache](/reference/cache).

?> Описываемые примеры работы с папками справедливы для всех функций `Cache`

Пример 1 - Для создания файла укажите только имя. Он будет находится в _папке аккаунта_.
```js
Cache.write('MySavedTracks.json', []);
```

Пример 2 - Чтобы создать _пользовательскую_ папку, укажите в строке: имя папки, слэш `/`, имя файла. Ниже пример создания файла `example.json` в папке `test`, которая разместится в _папке аккаунта_.
```js
Cache.write('test/example.json', []);
```

Пример 3 - Новую _пользовательскую_ папку можно создать в корне `Goofy Data`. Для этого укажите зарезервированное слово `root` и добавьте слэш `/`. Ниже пример создания файла `example.json`, который будет располагаться в папке `shared` в корне `Goofy Data`.
```js
Cache.write('root/shared/example.json', []);

// Аналогично
Cache.write('../shared/example.json', []);
```

Пример 4 - Если не хотите запутаться в расположениях, явно указывайте зарезервированные слова `root` и `user`, чтобы различать начало пути.
```js
// Папка shared в корне Goofy Data
Cache.write('root/shared/example.json', []);
Cache.write('../shared/example.json', []);

// Папка myfolder в папке аккаунта
Cache.write('user/myfolder/example.json', []);
Cache.write('./myfolder/example.json', []);
```

Пример 5 - Вложенность папок не ограничивается. 
```js
Cache.write('root/shared/radio/rock/lastfm.json', []);
Cache.write('user/private/radio/pixie.json', []);
```

Пример 6 - Если у вас несколько аккаунтов Spotify пользуются проектами goofy на одном аккаунте Google, можете создавать _файлы общего назначения_. Например, один проект собирает треки для радио и сохраняет в общую папку, а второй аккаунт просто читает этот файл не тратя свое время на такой же поиск.

?> Нельзя разместить файл в корневой папке `Goofy Data`. Они всегда будут переносится в папку аккаунта. Сделано для того, чтобы большинству не пришлось руками изменять структуру Диска. Обязательно укажите хотя бы одну папку, которая будет находится на одному уровне с папками аккаунта. 

```js
// Первый проект пишет в файл
Cache.write('root/shared/myradio.json', []);

// Второй проект читает его
let radioTracks = Cache.read('root/shared/myradio.json');
```

### Управление версиями

Файлы от [Cache](/reference/cache) хранятся на [Google Диске](https://drive.google.com/). В том числе [история прослушиваний](/details?id=История-прослушиваний). Удаленный файл попадает в корзину, где доступен еще 30 дней. Каждый файл имеет до 100 версий. Каждая запись в один и тот же файл создает новую версию. 

Если нужно откатиться к предыдущей версии файла
1. Зайдите в папку `Goofy Data` на [Google Диске](https://drive.google.com/)
2. Нажмите правой кнопкой мыши по файлу и выберите пункт `управлять версиями`
3. Найдите версию по дате изменения и в меню трех точек скачайте его
4. В этом же окне нажмите кнопку `загрузить новую версию` и выберите ранее скачанный файл

?> При откате истории прослушиваний, не оставляйте пустой файл. В нем должен быть хотя бы пустой массив `[]`.

## keep и slice

Среди функций `Selector` есть группа, которая начинается со слов `keep` и `slice`. Когда какую использовать?

Их различие заключается в отсутствии и наличии возвращаемого значения:
- Группа `keep` вызывает внутри себя функцию `replace`. Тем самым заменяя элементы исходного массива на новые. 
- Группа `slice` не изменяет исходный массив. Создается новый массив и возвращается как результат.

```js
// Данный код
let tracks = Source.getTopTracks('long');
tracks = Selector.sliceFirst(tracks, 10);

// Эквивалентен этому
let tracks = Source.getTopTracks('long');
Selector.keepFirst(tracks, 10);
```

Тогда зачем нужно две группы? Зависит от контекста использования. С `keep` код выглядит чище. Нет постоянных приравниваний в ту же переменную.

Функции `slice` полезны для комбинирования:
```js
// Выбор в одну строку
let tracks = Selector.sliceRandom(RecentTracks.get(), 100);

// Выбор до обновления плейлиста
Playlist.saveWithReplace({
    // ...
    tracks: Selector.sliceFirst(tracks, 50),
});
```